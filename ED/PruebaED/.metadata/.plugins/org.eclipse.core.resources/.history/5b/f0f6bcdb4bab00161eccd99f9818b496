package arbolesUO251017;

/**
 * Clase derivada de BSTNode añadiendo funcionalidad de AVL
 * @author Néstor
 * @version 2016-17
 * 
 */
public class AVLNode<T extends Comparable<T>> extends BSTNode<T>  {
	/**
	 * Para almacenar al Factor de balance. Puede no existir y calcularse cada vez a partir de la altura de los hijos.
	 */
	/**
	 * Para almacenar la altura del árbol
	 */
	public int height;
	
	/**
	 * Llama al padre y añade la información propia
	 * @param info la información que se mete en el nuevo nodo
	 */
	public AVLNode(T info)
	{
		super(info);
		height= 1;
//		balanceFactor= 0;
	}


	/**
	 * @return devuelve la altura del árbol del cual es raíz el nodo en cuestión
	 */
	public int getHeight() 
	{
		return height;
	}


	/**
	 * @return Devuelve el factor de balance según equilibrio del árbol del cual es raíz
	 */
	public byte getBF()
	{
//		if (getLeft() == null && getRight() == null)
//		{
//			return 0;
//		}
//		
//		else if (getLeft() != null && getRight() == null)
//		{
//			balanceFactor= (byte) (0 - getLeft().getHeight());
//			return balanceFactor;
//		}
//		
//		else if (getLeft() == null && getRight() != null)
//		{
//			balanceFactor= (byte) (getRight().getHeight());
//			return balanceFactor;
//		}
//		
//		else
//		{
//			balanceFactor= (byte) (getRight().getHeight() - getLeft().getHeight());
//			return balanceFactor;
//		}
		byte hIzq= 0;
		byte hDer= 0;
		
		if (getLeft() != null)
		{
			hIzq= (byte) getLeft().getHeight();
		}
		
		if (getRight() != null)
		{
			hDer= (byte) getRight().getHeight();
		}
		
		return (byte) (hDer - hIzq);
	}


	/**
	 * Actualiza la altura del nodo en el árbol utilizando la altura de los hijos
	 */
	protected void updateHeight() 
	{
		if (getLeft() == null && getRight() == null)
		{
			this.height= 1;
		}
		
		else if (getRight() == null)
		{
			this.height= getLeft().getHeight() + 1;
		}
		
		else if (getLeft() == null)
		{
			this.height= getRight().getHeight() + 1;
		}
		
		else 
		{
			if (getLeft().getHeight() > getRight().getHeight())
			{
				this.height= getLeft().getHeight() + 1;
			}
			else
			{
				this.height= getRight().getHeight() + 1;
			}
//			int alturaMax= elegirHMax();
//			height= 1 + alturaMax;
		}
	}
	
//	private int elegirHMax()
//	{
//		int altIzquierda= 0;
//		int altDerecha= 0;
//		
//		if (getLeft() != null)
//		{
//			altIzquierda= getLeft().getHeight();
//		}
//		
//		if (getRight() != null)
//		{
//			altDerecha= getRight().getHeight();
//		}
//		
//		if ((altIzquierda - altDerecha) == 0 || (altIzquierda - altDerecha) > 0)
//		{
//			return altIzquierda;
//		}
//		
//		else
//		{
//			return altDerecha;
//		}
//	}
	
	/* (non-Javadoc)
	 * @see BSTNode#getLeft()
	 */
	public AVLNode<T> getLeft(){
		return (AVLNode<T>) super.getLeft();
	}
	
	/* (non-Javadoc)
	 * @see BSTNode#getRight()
	 */
	public AVLNode<T> getRight() {
		return (AVLNode<T>) super.getRight();
	}
	
	public AVLNode<T> getRaiz()
	{
		return (AVLNode<T>) super
	}
	
// No se necesitan los setters, valen los heredados


	/* (non-Javadoc)
	 * @see BSTNode#toString()
	 * Añade factor de balance
	 */
	@Override
	public String toString() {
		return super.toString()+":FB="+ getBF();
	}
}